(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const c of o)if(c.type==="childList")for(const i of c.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function e(o){const c={};return o.integrity&&(c.integrity=o.integrity),o.referrerPolicy&&(c.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?c.credentials="include":o.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function s(o){if(o.ep)return;o.ep=!0;const c=e(o);fetch(o.href,c)}})();class mt{points;constructor(t=[]){this.points=t}}const it=(n,t)=>`Заданный угол ${n}° прямоугольника ${JSON.stringify(t)} подсоединения не перпендикулярен грани`,T=15,et=3,ct=3,W=8,b=.001,Pt=(n,t)=>n.x*t.y-n.y*t.x,It=(n,t)=>n.x*t.x+n.y*t.y,F=(n,t,e=!1,s=!1)=>{let o=Math.atan2(Pt(n,t),It(n,t));return o<0&&(o+=2*Math.PI),s&&(o=2*Math.PI-o),e?o*180/Math.PI:o},w=(n,t)=>({x:n.x-t.x,y:n.y-t.y}),at=(n,t)=>({x:n.x*t.x,y:n.y*t.y}),E=(n,t)=>({x:n.x+t.x,y:n.y+t.y}),v=n=>{const t=Math.sqrt(n.x*n.x+n.y*n.y);if(t===0)return R();const e=n.x/t,s=n.y/t;return{x:Math.abs(e)-b<=0?0:Math.abs(e)+b>=1?Math.sign(e)*1:e,y:Math.abs(s)-b<=0?0:Math.abs(s)+b>=1?Math.sign(s)*1:s}},O=(n,t,e=!1,s=!1)=>{const o=s?360:2*Math.PI;let c=t%o;c<0&&(c+=o);const i=s?c*Math.PI/180:c,a=e?-1:1,l=Math.cos(i),u=Math.sin(i)*a;return{x:n.x*l-n.y*u,y:n.x*u+n.y*l}},rt=(n,t)=>{const e=w(t,n);return e.x**2+e.y**2},A=n=>({x:n.x,y:document.documentElement.offsetHeight-n.y});class ht extends Error{constructor(t){super(t),this.name="PointNotOnTheEdgeError"}}class K extends Error{constructor(t){super(t),this.name="ConnectionPointAngleNotPerpendicularError"}}const dt=(n,t,e)=>{const s=w(t,n),o=w(e,n),c=Math.min(t.x,e.x)-b<=n.x&&n.x<=Math.max(t.x,e.x)+b,i=Math.min(t.y,e.y)-b<=n.y&&n.y<=Math.max(t.y,e.y)+b,a=Pt(s,o);return a>=0&&a<=b&&c&&i},G=(n,t,e=!1)=>{const s=I(n),[o,c,i]=s;let a=Math.min(o.x,i.x)<=t.x&&t.x<=Math.max(o.x,i.x),l=Math.min(o.y,i.y)<=t.y&&t.y<=Math.max(o.y,i.y);return e&&(a=Math.min(o.x,i.x)<t.x&&t.x<Math.max(o.x,i.x),l=Math.min(o.y,i.y)<t.y&&t.y<Math.max(o.y,i.y)),a&&l},B=(n,t)=>{const[e,s]=n,[o,c]=t,i={x:s.x-e.x,y:s.y-e.y},a={x:c.x-o.x,y:c.y-o.y},l=i.x*a.y-i.y*a.x;if(l===0){if(!(e.x*(s.y-o.y)+s.x*(o.y-e.y)+o.x*(e.y-s.y)===0))return null;const d=((o.x-e.x)*i.x+(o.y-e.y)*i.y)/(i.x*i.x+i.y*i.y),f=((c.x-e.x)*i.x+(c.y-e.y)*i.y)/(i.x*i.x+i.y*i.y),m=Math.min(d,f),x=Math.max(d,f);if(x<0||m>1)return null;const p=Math.max(0,m),y=Math.min(1,x);if(p===y){const P=e.x+p*i.x,C=e.y+p*i.y;return{x:P,y:C}}else{const P={x:e.x+p*i.x,y:e.y+p*i.y},C={x:e.x+y*i.x,y:e.y+y*i.y};return[P,C]}}const u=((e.y-o.y)*a.x-(e.x-o.x)*a.y)/l,g=-((e.y-o.y)*i.x-(e.x-o.x)*i.y)/l;if(u>=0&&u<=1&&g>=0&&g<=1){const h=e.x+u*i.x,d=e.y+u*i.y;return{x:h,y:d}}return null};function zt(n,t,e,s,o){const c=n[t],i=n[e],a=Wt(n,s,o),l=new Map,u=new Map,g=new Set;l.set(`${c.x},${c.y}`,0),u.set(`${c.x},${c.y}`,null);const h=[{...c,dist:0}];for(;h.length>0;){h.sort((x,p)=>x.dist-p.dist);const d=h.shift(),f=`${d.x},${d.y}`;if(g.has(f))continue;if(g.add(f),d.x===i.x&&d.y===i.y)return{path:St(u,i),distance:l.get(f)};const m=a.get(f)||[];for(const x of m){const p=`${x.x},${x.y}`,y=l.get(f)+jt(d,x);y<(l.get(p)??1/0)&&(l.set(p,y),u.set(p,d),h.push({...x,dist:y}))}}return{path:[],distance:1/0}}function jt(n,t){return Math.abs(n.x-t.x)+Math.abs(n.y-t.y)}function St(n,t){const e=[];let s=`${t.x},${t.y}`,o=n.get(s);for(;o;)e.unshift({x:o.x,y:o.y}),s=`${o.x},${o.y}`,o=n.get(s);return e.push({x:t.x,y:t.y}),e}function Wt(n,t,e){const s=new Map,o=N(t),c=N(e);for(let i=0;i<n.length;i++){const a=n[i],l=`${a.x},${a.y}`;s.set(l,[]);const u=n.filter(h=>h.x===a.x&&h.y!==a.y);u.sort((h,d)=>h.y-d.y);for(const h of u){let d=0;for(const f of o){const m=j(h,a,[f]),x=B(f,[h,a]);m&&!x&&(d+=1)}for(const f of c){const m=j(h,a,[f]),x=B(f,[h,a]);m&&!x&&(d+=1)}d<=1&&s.get(l).push(h)}const g=n.filter(h=>h.y===a.y&&h.x!==a.x);g.sort((h,d)=>h.x-d.x);for(const h of g){let d=0;for(const f of o){const m=j(h,a,[f]),x=B(f,[h,a]);m&&!x&&(d+=1)}for(const f of c){const m=j(h,a,[f]),x=B(f,[h,a]);m&&!x&&(d+=1)}d<=1&&s.get(l).push(h)}}return s}const Ot=(n,t,e,s)=>{const{x:o,y:c}=n,{x:i,y:a}=t,{x:l,y:u}=e,{x:g,y:h}=s,d=i-o,f=a-c,m=g-l,x=h-u,p=d*x-f*m;if(Math.abs(p)<b)return null;const y=l-o,P=u-c,C=(y*x-P*m)/p,z=(y*f-P*d)/p;return C>=0&&C<=1&&z>=0&&z<=1?{x:o+C*d,y:c+C*f}:null},j=(n,t,e)=>{const{x:s,y:o}=n;let c=null,i=1/0;for(const a of e){const[l,u]=a,g=Ot(n,t,l,u);if(g){const h=g.x-s,d=g.y-o,f=h*h+d*d;f<i&&(i=f,c={point:g,segment:a})}}return c},I=({position:n,size:t})=>{const e=t.width/2,s=t.height/2,o={x:n.x-e,y:n.y+s},c={x:n.x+e,y:n.y+s},i={x:n.x-e,y:n.y-s},a={x:n.x+e,y:n.y-s};return[o,c,a,i]},lt=(n,t)=>Math.abs(n.x-t.x)<b&&Math.abs(n.y-t.y)<b,ut=(n,t,e,s)=>{const o=N(n),c=N(t);let i=!1,a=o[0];for(const r of o){const[S,D]=r;if(dt(e.point,S,D)){i=!0,a=r;break}}if(!i)throw new ht("Точка 1 не лежит ни на одной грани");let l=!1,u=c[0];for(const r of c){const[S,D]=r;if(dt(s.point,S,D)){l=!0,u=r;break}}if(!l)throw new ht("Точка 2 не лежит ни на одной грани");if(e.angle%90!==0)throw new K(`Заданный угол ${e.angle}° первого прямоугольника подсоединения не перпендикулярен грани`);if(s.angle%90!==0)throw new K(`Заданный угол ${s.angle}° второго прямоугольника подсоединения не перпендикулярен грани`);const g={x:1,y:0},h=v(w(a[1],a[0]));let d=v(O(h,90,!1,!0)),f=F(g,d,!0,!1);if(f!==e.angle&&!xt(e.point,n))throw new K(it(e.angle,n));const m=v(w(u[1],u[0]));if(d=v(O(m,90,!1,!0)),f=F(g,d,!0,!1),f!==s.angle&&!xt(s.point,t))throw new K(it(s.angle,t));const x={x:1,y:0},p={x:T,y:T},y=E(at(v(O(x,e.angle,!1,!0)),p),e.point),P=E(at(v(O(x,s.angle,!1,!0)),p),s.point),C=w(P,y),z={size:{width:n.size.width+2*T,height:n.size.height+2*T},position:n.position},q={size:{width:t.size.width+2*T,height:t.size.height+2*T},position:t.position},H=I(z),Mt=N(z),_=I(q),Nt=N(q),$=Math.min(...H.map(r=>r.x),..._.map(r=>r.x)),U=Math.max(...H.map(r=>r.x),..._.map(r=>r.x)),k=Math.min(...H.map(r=>r.y),..._.map(r=>r.y)),X=Math.max(...H.map(r=>r.y),..._.map(r=>r.y)),nt=rt(y,R()),ot=rt(y,R()),Y=nt<ot?y:P,V=nt<ot?P:y,Ct={position:{x:(Y.x+U)/2,y:(Y.y+X)/2},size:{width:Math.abs(Y.x-U),height:Math.abs(Y.y-X)}},wt={position:{x:(V.x+$)/2,y:(V.y+k)/2},size:{width:Math.abs(V.x-$),height:Math.abs(V.y-k)}},Et=N(Ct),bt=N(wt),st=w({x:$,y:k},{x:U,y:X}),vt={position:{x:$+Math.abs(st.x/2),y:k+Math.abs(st.y/2)},size:{width:U-$,height:X-k}},Tt=N(vt),At={position:{x:Math.min(y.x,P.x)+Math.abs(C.x/2),y:Math.min(y.y,P.y)+Math.abs(C.y/2)},size:{width:Math.abs(C.x),height:Math.abs(C.y)}},Rt=N(At),L=[...Mt,...Nt,...Rt,...Tt,...Et,...bt],J=[];for(let r=0;r<L.length;r++){const S=L[r];for(let D=0;D<L.length;D++){if(S===L[D])continue;const Z=B(S,L[D]);if(Array.isArray(Z)){J.push(...Z);continue}Z&&J.push(Z)}}const Q=[...new Map(J.map(r=>[`${r.x},${r.y}`,r])).values()].filter(r=>lt(y,r)||lt(P,r)||!G(z,r,!0)&&!G(q,r,!0)),{path:Dt}=zt(Q,Q.findIndex(r=>r.x===y.x&&r.y===y.y),Q.findIndex(r=>r.x===P.x&&r.y===P.y),ft(z,-et/2),ft(q,-et/2));return[e.point,...Dt,s.point]},ft=(n,t)=>({...n,size:{width:n.size.width+t,height:n.size.height+t}}),N=n=>{const t=I(n);return[[t[0],t[1]],[t[1],t[2]],[t[2],t[3]],[t[3],t[0]]]},tt=n=>n.x===0&&n.y===0,R=()=>({x:0,y:0}),xt=(n,t)=>{const e=I(t);for(const s of e)if(n.x===s.x&&n.y===s.y)return!0;return!1};class yt extends mt{rect={size:{width:1,height:1},position:{x:1,y:1}};constructor(t){super(I(t)),this.rect=t}}class $t{points;constructor(t=[]){this.points=t}}class gt{shape;adjacentNode=null;pathToAdjacentNode=null;constructor(t,e,s){this.shape=t,this.adjacentNode=e,this.pathToAdjacentNode=s}assignTranslation(t,e){this.shape instanceof M&&(t&&(this.shape.translation=t),e&&(this.shape.connectionPointTranslation=e))}initializePathToAdjecentNode(){if(this.adjacentNode&&this.shape instanceof M&&this.adjacentNode.shape instanceof M){const t=new pt(ut(this.shape.model.rect,this.adjacentNode.shape.model.rect,this.shape.connectionPoint,this.adjacentNode.shape.connectionPoint),"#3f9");this.pathToAdjacentNode=t,this.adjacentNode.pathToAdjacentNode=t}}createAdjacentNodePathWithTranslations(){if(this.adjacentNode&&this.shape instanceof M&&this.adjacentNode.shape instanceof M){const t={point:E(this.shape.connectionPoint.point,this.shape.translation),angle:this.shape.connectionPoint.angle},e={...E(this.shape.model.rect.position,this.shape.translation)};tt(this.shape.connectionPointTranslation)||this.calculateMouseFromCenterEdgeIntersection();const s=new pt(ut({...this.shape.model.rect,position:e},this.adjacentNode.shape.model.rect,t,this.adjacentNode.shape.connectionPoint),"#3f9");this.pathToAdjacentNode=s,this.adjacentNode.pathToAdjacentNode=s}}calculateMouseFromCenterEdgeIntersection(){if(this.adjacentNode&&this.shape instanceof M&&this.adjacentNode.shape instanceof M){const t=j(E(this.shape.model.rect.position,this.shape.connectionPointTranslation),this.shape.model.rect.position,N(this.shape.model.rect));let e=this.shape.connectionPoint.angle;if(t){const s=v(O(v(w(t.segment[1],t.segment[0])),90,!1,!0));e=F({x:1,y:0},s,!0);const o={point:t.point,angle:e};o.point.x=Math.round(o.point.x),o.point.y=Math.round(o.point.y),this.shape.connectionPoint=o}}}intersectsWithNode(t){if(this.shape instanceof M&&t.shape instanceof M){const e={...E(this.shape.model.rect.position,this.shape.translation)},s={size:{width:this.shape.model.rect.size.width+2*T,height:this.shape.model.rect.size.height+2*T},position:e},o={size:{width:t.shape.model.rect.size.width+2*T,height:t.shape.model.rect.size.height+2*T},position:t.shape.model.rect.position},c=N(s),i=N(o),a=[];for(const u of c)j(u[0],u[1],i)&&a.push(u);const l=[];for(const u of i)j(u[0],u[1],c)&&l.push(u);if(a.length>0&&l.length>0)return[a,l]}return null}changeConnectionPointPosition(t){if(this.shape instanceof M){const e=N(this.shape.model.rect);let s=null;for(const o of e){s=o;const c=v(w(o[1],o[0]));for(const i of t){const a=v(w(i[1],i[0]));if(F(a,c,!0)===0){s=null;break}}if(s)break}if(s){const o=F({x:1,y:0},O(v(w(s[1],s[0])),90,!1,!0),!0)%360,c={x:Math.round(s[0].x+s[1].x)/2,y:Math.round(s[0].y+s[1].y)/2};this.shape.connectionPoint={angle:o,point:c}}}}commitTranslation(){if(this.shape instanceof M){const t={point:E(this.shape.connectionPoint.point,this.shape.translation),angle:this.shape.connectionPoint.angle},e={...E(this.shape.model.rect.position,this.shape.translation)};tt(this.shape.translation)||(this.shape.model.rect.position=e,this.shape.connectionPoint.point=t.point,this.shape.model.points=I(this.shape.model.rect),this.shape.points=I(this.shape.model.rect)),tt(this.shape.connectionPointTranslation)||this.calculateMouseFromCenterEdgeIntersection(),this.shape.translation=R(),this.shape.connectionPointTranslation=R()}}}class kt extends mt{bgColor="#000";translation=R();draw(t){const{x:e,y:s}=A(E(this.points[0],this.translation));t.beginPath(),t.moveTo(e,s);for(let o=1;o<this.points.length;o++){const{x:c,y:i}=A(E(this.points[o],this.translation));t.lineTo(c,i)}t.fillStyle=this.bgColor,t.fill()}}class M extends kt{borderColor="#000";connectionPointColor="#3ef";connectionPoint;model;connectionPointTranslation=R();constructor(t,e,s,o,c){super(t.points),this.borderColor=o,this.bgColor=s,this.connectionPointColor=c,this.connectionPoint=e,this.model=t}draw(t){const e={width:this.model.rect.size.width+ct,height:this.model.rect.size.height+ct},s=A(E(this.model.rect.position,this.translation));t.fillStyle=this.borderColor,t.fillRect(s.x-e.width/2,s.y-e.height/2,e.width,e.height),super.draw(t);const o=A(E(this.connectionPoint.point,this.translation));t.fillStyle=this.connectionPointColor,t.fillRect(o.x-W/2,o.y-W/2,W,W)}}class pt extends $t{color;constructor(t,e){super(t),this.color=e}draw(t){const{x:e,y:s}=A(this.points[0]);t.beginPath(),t.moveTo(e,s);for(let o=1;o<this.points.length;o++){const{x:c,y:i}=A(this.points[o]);t.lineTo(c,i)}t.lineWidth=et,t.strokeStyle=this.color,t.stroke()}}class Lt{mouseDownCallbacks=[];mouseUpCallbacks=[];mouseMoveCallbacks=[];constructor(){}initialize(){}addMouseDownCallback(t){this.mouseDownCallbacks.push(t),document.addEventListener("mousedown",t)}addMouseMoveCallback(t){this.mouseDownCallbacks.push(t),document.addEventListener("mousemove",t)}addMouseUpCallback(t){this.mouseDownCallbacks.push(t),document.addEventListener("mouseup",t)}clearCallbacks(){for(const t of this.mouseDownCallbacks)document.removeEventListener("mousedown",t);for(const t of this.mouseUpCallbacks)document.removeEventListener("mouseup",t);for(const t of this.mouseMoveCallbacks)document.removeEventListener("mousemove",t)}}class Bt{canvas;areaNodes=[];selectedNode=null;selectedConnectionPointNode=null;inputService;mouseDownCoordinates=null;rafID=-1;constructor(){this.inputService=new Lt}init(){const t=document.querySelector("#canvas"),e=document.documentElement.offsetWidth,s=document.documentElement.offsetHeight;if(t)this.canvas=document.querySelector("#canvas"),this.canvas.width=e,this.canvas.height=s;else throw new Error("Canvas элемент не инициализирован");const o=50,c=50,i=50,a=50,l={x:Math.round(e/2),y:Math.round(s/2)+150},u={x:Math.round(e/2),y:Math.round(s/2)-100},g=new M(new yt({position:{...l},size:{width:o,height:c}}),{point:{x:l.x+o/2,y:l.y},angle:0},"#afa","#33f","#000"),h=new M(new yt({position:{...u},size:{width:i,height:a}}),{point:{x:u.x,y:u.y-a/2},angle:270},"#afa","#33f","#000"),d=new gt(h,null,null),f=new gt(g,d,null);d.adjacentNode=f,f.initializePathToAdjecentNode(),this.areaNodes.push(f,d),this.inputService.addMouseDownCallback(this.onMouseDownAreaNodeSelect.bind(this)),this.inputService.addMouseMoveCallback(this.onMouseMoveSelectedAreaNode.bind(this)),this.inputService.addMouseUpCallback(this.onMouseUpAreaNodeSelect.bind(this))}start(){this.rafID=requestAnimationFrame(this.render.bind(this))}render(){if(typeof this.canvas<"u"){const t=this.canvas.getContext("2d");if(this.canvas&&typeof t<"u"&&t!==null){t.clearRect(0,0,document.documentElement.offsetWidth,document.documentElement.offsetHeight);for(const e of this.areaNodes)e.adjacentNode&&e.pathToAdjacentNode&&e.pathToAdjacentNode.draw(t);for(const e of this.areaNodes)e.shape.draw(t)}}}onMouseDownAreaNodeSelect(t){const e=A({x:t.clientX,y:t.clientY});for(const s of this.areaNodes)if(s.shape instanceof M){const o={position:s.shape.connectionPoint.point,size:{width:W,height:W}};if(G(o,e)){this.selectedConnectionPointNode=s,this.mouseDownCoordinates=e;return}G(s.shape.model.rect,e)&&(this.selectedNode=s,this.mouseDownCoordinates=e)}}onMouseMoveSelectedAreaNode(t){if(this.mouseDownCoordinates){if(this.selectedNode){const e=A({x:t.clientX,y:t.clientY}),s=w(e,this.mouseDownCoordinates);if(this.selectedNode.assignTranslation(s,R()),this.selectedNode.adjacentNode){const o=this.selectedNode.intersectsWithNode(this.selectedNode.adjacentNode);o&&(this.selectedNode.changeConnectionPointPosition(o[0]),this.selectedNode.adjacentNode.changeConnectionPointPosition(o[1]))}this.selectedNode.createAdjacentNodePathWithTranslations(),this.rafID=requestAnimationFrame(this.render.bind(this))}if(this.selectedConnectionPointNode&&this.selectedConnectionPointNode.shape instanceof M){const e=A({x:t.clientX,y:t.clientY}),s=w(e,this.selectedConnectionPointNode.shape.model.rect.position);this.selectedConnectionPointNode.assignTranslation(R(),s),this.selectedConnectionPointNode.createAdjacentNodePathWithTranslations(),this.rafID=requestAnimationFrame(this.render.bind(this))}}}onMouseUpAreaNodeSelect(){this.selectedNode&&(this.selectedNode.commitTranslation(),console.log(this.selectedNode.intersectsWithNode(this.selectedNode.adjacentNode))),this.selectedConnectionPointNode&&this.selectedConnectionPointNode.commitTranslation(),this.selectedNode=null,this.selectedConnectionPointNode=null,this.mouseDownCoordinates=null}}document.addEventListener("DOMContentLoaded",()=>{const n=new Bt;n.init(),n.start()});
