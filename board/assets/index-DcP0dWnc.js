(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function e(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(o){if(o.ep)return;o.ep=!0;const a=e(o);fetch(o.href,a)}})();class pt{points;constructor(t=[]){this.points=t}}const st=(n,t)=>`Заданный угол ${n}° прямоугольника ${JSON.stringify(t)} подсоединения не перпендикулярен грани`,j=15,Dt=3,it=3,z=8,v=.001,gt=(n,t)=>n.x*t.y-n.y*t.x,Rt=(n,t)=>n.x*t.x+n.y*t.y,K=(n,t,e=!1,s=!1)=>{let o=Math.atan2(gt(n,t),Rt(n,t));return o<0&&(o+=2*Math.PI),s&&(o=2*Math.PI-o),e?o*180/Math.PI:o},w=(n,t)=>({x:n.x-t.x,y:n.y-t.y}),at=(n,t)=>({x:n.x*t.x,y:n.y*t.y}),C=(n,t)=>({x:n.x+t.x,y:n.y+t.y}),E=n=>{const t=Math.sqrt(n.x*n.x+n.y*n.y);if(t===0)return A();const e=n.x/t,s=n.y/t;return{x:Math.abs(e)-v<=0?0:Math.abs(e)+v>=1?Math.sign(e)*1:e,y:Math.abs(s)-v<=0?0:Math.abs(s)+v>=1?Math.sign(s)*1:s}},O=(n,t,e=!1,s=!1)=>{const o=s?360:2*Math.PI;let a=t%o;a<0&&(a+=o);const i=s?a*Math.PI/180:a,c=e?-1:1,u=Math.cos(i),f=Math.sin(i)*c;return{x:n.x*u-n.y*f,y:n.x*f+n.y*u}},ct=(n,t)=>{const e=w(t,n);return e.x**2+e.y**2},T=n=>({x:n.x,y:document.documentElement.offsetHeight-n.y});class rt extends Error{constructor(t){super(t),this.name="PointNotOnTheEdgeError"}}class Z extends Error{constructor(t){super(t),this.name="ConnectionPointAngleNotPerpendicularError"}}const ht=(n,t,e)=>{const s=w(t,n),o=w(e,n),a=Math.min(t.x,e.x)-v<=n.x&&n.x<=Math.max(t.x,e.x)+v,i=Math.min(t.y,e.y)-v<=n.y&&n.y<=Math.max(t.y,e.y)+v,c=gt(s,o);return c>=0&&c<=v&&a&&i},G=(n,t,e=!1)=>{const s=R(n),[o,a,i]=s;let c=Math.min(o.x,i.x)<=t.x&&t.x<=Math.max(o.x,i.x),u=Math.min(o.y,i.y)<=t.y&&t.y<=Math.max(o.y,i.y);return e&&(c=Math.min(o.x,i.x)<t.x&&t.x<Math.max(o.x,i.x),u=Math.min(o.y,i.y)<t.y&&t.y<Math.max(o.y,i.y)),c&&u},B=(n,t)=>{const[e,s]=n,[o,a]=t,i={x:s.x-e.x,y:s.y-e.y},c={x:a.x-o.x,y:a.y-o.y},u=i.x*c.y-i.y*c.x;if(u===0){if(!(e.x*(s.y-o.y)+s.x*(o.y-e.y)+o.x*(e.y-s.y)===0))return null;const l=((o.x-e.x)*i.x+(o.y-e.y)*i.y)/(i.x*i.x+i.y*i.y),d=((a.x-e.x)*i.x+(a.y-e.y)*i.y)/(i.x*i.x+i.y*i.y),m=Math.min(l,d),x=Math.max(l,d);if(x<0||m>1)return null;const g=Math.max(0,m),y=Math.min(1,x);if(g===y){const P=e.x+g*i.x,M=e.y+g*i.y;return{x:P,y:M}}else{const P={x:e.x+g*i.x,y:e.y+g*i.y},M={x:e.x+y*i.x,y:e.y+y*i.y};return[P,M]}}const f=((e.y-o.y)*c.x-(e.x-o.x)*c.y)/u,p=-((e.y-o.y)*i.x-(e.x-o.x)*i.y)/u;if(f>=0&&f<=1&&p>=0&&p<=1){const h=e.x+f*i.x,l=e.y+f*i.y;return{x:h,y:l}}return null};function St(n,t,e,s,o){const a=n[t],i=n[e],c=zt(n,s,o),u=new Map,f=new Map,p=new Set;u.set(`${a.x},${a.y}`,0),f.set(`${a.x},${a.y}`,null);const h=[{...a,dist:0}];for(;h.length>0;){h.sort((x,g)=>x.dist-g.dist);const l=h.shift(),d=`${l.x},${l.y}`;if(p.has(d))continue;if(p.add(d),l.x===i.x&&l.y===i.y)return{path:jt(f,i),distance:u.get(d)};const m=c.get(d)||[];for(const x of m){const g=`${x.x},${x.y}`,y=u.get(d)+It(l,x);y<(u.get(g)??1/0)&&(u.set(g,y),f.set(g,l),h.push({...x,dist:y}))}}return{path:[],distance:1/0}}function It(n,t){return Math.abs(n.x-t.x)+Math.abs(n.y-t.y)}function jt(n,t){const e=[];let s=`${t.x},${t.y}`,o=n.get(s);for(;o;)e.unshift({x:o.x,y:o.y}),s=`${o.x},${o.y}`,o=n.get(s);return e.push({x:t.x,y:t.y}),e}function zt(n,t,e){const s=new Map,o=N(t),a=N(e);for(let i=0;i<n.length;i++){const c=n[i],u=`${c.x},${c.y}`;s.set(u,[]);const f=n.filter(h=>h.x===c.x&&h.y!==c.y);f.sort((h,l)=>h.y-l.y);for(const h of f){let l=0;for(const d of o){const m=W(h,c,[d]),x=B(d,[h,c]);m&&!x&&(l+=1)}for(const d of a){const m=W(h,c,[d]),x=B(d,[h,c]);m&&!x&&(l+=1)}l<=1&&s.get(u).push(h)}const p=n.filter(h=>h.y===c.y&&h.x!==c.x);p.sort((h,l)=>h.x-l.x);for(const h of p){let l=0;for(const d of o){const m=W(h,c,[d]),x=B(d,[h,c]);m&&!x&&(l+=1)}for(const d of a){const m=W(h,c,[d]),x=B(d,[h,c]);m&&!x&&(l+=1)}l<=1&&s.get(u).push(h)}}return s}const Ot=(n,t,e,s)=>{const{x:o,y:a}=n,{x:i,y:c}=t,{x:u,y:f}=e,{x:p,y:h}=s,l=i-o,d=c-a,m=p-u,x=h-f,g=l*x-d*m;if(Math.abs(g)<v)return null;const y=u-o,P=f-a,M=(y*x-P*m)/g,S=(y*d-P*l)/g;return M>=0&&M<=1&&S>=0&&S<=1?{x:o+M*l,y:a+M*d}:null},W=(n,t,e)=>{const{x:s,y:o}=n;let a=null,i=1/0;for(const c of e){const[u,f]=c,p=Ot(n,t,u,f);if(p){const h=p.x-s,l=p.y-o,d=h*h+l*l;d<i&&(i=d,a={point:p,segment:c})}}return a},R=({position:n,size:t})=>{const e=t.width/2,s=t.height/2,o={x:n.x-e,y:n.y+s},a={x:n.x+e,y:n.y+s},i={x:n.x-e,y:n.y-s},c={x:n.x+e,y:n.y-s};return[o,a,c,i]},lt=(n,t,e,s)=>{const o=N(n),a=N(t);let i=!1,c=o[0];for(const r of o){const[I,D]=r;if(ht(e.point,I,D)){i=!0,c=r;break}}if(!i)throw new rt("Точка 1 не лежит ни на одной грани");let u=!1,f=a[0];for(const r of a){const[I,D]=r;if(ht(s.point,I,D)){u=!0,f=r;break}}if(!u)throw new rt("Точка 2 не лежит ни на одной грани");if(e.angle%90!==0)throw new Z(`Заданный угол ${e.angle}° первого прямоугольника подсоединения не перпендикулярен грани`);if(s.angle%90!==0)throw new Z(`Заданный угол ${s.angle}° второго прямоугольника подсоединения не перпендикулярен грани`);const p={x:1,y:0},h=E(w(c[1],c[0]));let l=E(O(h,90,!1,!0)),d=K(p,l,!0,!1);if(d!==e.angle&&!ut(e.point,n))throw new Z(st(e.angle,n));const m=E(w(f[1],f[0]));if(l=E(O(m,90,!1,!0)),d=K(p,l,!0,!1),d!==s.angle&&!ut(s.point,t))throw new Z(st(s.angle,t));const x={x:1,y:0},g={x:j,y:j},y=C(at(E(O(x,e.angle,!1,!0)),g),e.point),P=C(at(E(O(x,s.angle,!1,!0)),g),s.point),M=w(P,y),S={size:{width:n.size.width+2*j,height:n.size.height+2*j},position:n.position},_={size:{width:t.size.width+2*j,height:t.size.height+2*j},position:t.position},F=R(S),mt=N(S),q=R(_),Pt=N(_),$=Math.min(...F.map(r=>r.x),...q.map(r=>r.x)),H=Math.max(...F.map(r=>r.x),...q.map(r=>r.x)),L=Math.min(...F.map(r=>r.y),...q.map(r=>r.y)),U=Math.max(...F.map(r=>r.y),...q.map(r=>r.y)),et=ct(y,A()),nt=ct(y,A()),V=et<nt?y:P,X=et<nt?P:y,Mt={position:{x:(V.x+H)/2,y:(V.y+U)/2},size:{width:Math.abs(V.x-H),height:Math.abs(V.y-U)}},Nt={position:{x:(X.x+$)/2,y:(X.y+L)/2},size:{width:Math.abs(X.x-$),height:Math.abs(X.y-L)}},Ct=N(Mt),wt=N(Nt),ot=w({x:$,y:L},{x:H,y:U}),Et={position:{x:$+Math.abs(ot.x/2),y:L+Math.abs(ot.y/2)},size:{width:H-$,height:U-L}},bt=N(Et),vt={position:{x:Math.min(y.x,P.x)+Math.abs(M.x/2),y:Math.min(y.y,P.y)+Math.abs(M.y/2)},size:{width:Math.abs(M.x),height:Math.abs(M.y)}},Tt=N(vt),k=[...mt,...Pt,...Tt,...bt,...Ct,...wt],J=[];for(let r=0;r<k.length;r++){const I=k[r];for(let D=0;D<k.length;D++){if(I===k[D])continue;const Y=B(I,k[D]);if(Array.isArray(Y)){J.push(...Y);continue}Y&&J.push(Y)}}const Q=[...new Map(J.map(r=>[`${r.x},${r.y}`,r])).values()].filter(r=>!G(S,r,!0)&&!G(_,r,!0)),At=St(Q,Q.findIndex(r=>r.x===y.x&&r.y===y.y),Q.findIndex(r=>r.x===P.x&&r.y===P.y),dt(S,-1),dt(_,-1)).path;return[e.point,...At,s.point]},dt=(n,t)=>({...n,size:{width:n.size.width+t,height:n.size.height+t}}),N=n=>{const t=R(n);return[[t[0],t[1]],[t[1],t[2]],[t[2],t[3]],[t[3],t[0]]]},tt=n=>n.x===0&&n.y===0,A=()=>({x:0,y:0}),ut=(n,t)=>{const e=R(t);for(const s of e)if(n.x===s.x&&n.y===s.y)return!0;return!1};class ft extends pt{rect={size:{width:1,height:1},position:{x:1,y:1}};constructor(t){super(R(t)),this.rect=t}}class Wt{points;constructor(t=[]){this.points=t}}class xt{shape;adjacentNode=null;pathToAdjacentNode=null;constructor(t,e,s){this.shape=t,this.adjacentNode=e,this.pathToAdjacentNode=s}assignTranslation(t,e){this.shape instanceof b&&(t&&(this.shape.translation=t),e&&(this.shape.connectionPointTranslation=e))}initializePathToAdjecentNode(){if(this.adjacentNode&&this.shape instanceof b&&this.adjacentNode.shape instanceof b){const t=new yt(lt(this.shape.model.rect,this.adjacentNode.shape.model.rect,this.shape.connectionPoint,this.adjacentNode.shape.connectionPoint),"#3f9");this.pathToAdjacentNode=t,this.adjacentNode.pathToAdjacentNode=t}}createAdjacentNodePathWithTranslations(){if(this.adjacentNode&&this.shape instanceof b&&this.adjacentNode.shape instanceof b){let t={point:C(this.shape.connectionPoint.point,this.shape.translation),angle:this.shape.connectionPoint.angle};const e={...C(this.shape.model.rect.position,this.shape.translation)};if(!tt(this.shape.connectionPointTranslation)){const o=W(C(this.shape.model.rect.position,this.shape.connectionPointTranslation),this.shape.model.rect.position,N(this.shape.model.rect));let a=this.shape.connectionPoint.angle;if(o){const i=E(O(E(w(o.segment[1],o.segment[0])),90,!1,!0));a=K({x:1,y:0},i,!0),t={point:o.point,angle:a},t.point.x=Math.round(t.point.x),t.point.y=Math.round(t.point.y),this.shape.connectionPoint=t}}const s=new yt(lt({...this.shape.model.rect,position:e},this.adjacentNode.shape.model.rect,t,this.adjacentNode.shape.connectionPoint),"#3f9");this.pathToAdjacentNode=s,this.adjacentNode.pathToAdjacentNode=s}}commitTranslation(){if(this.shape instanceof b){let t={point:C(this.shape.connectionPoint.point,this.shape.translation),angle:this.shape.connectionPoint.angle};const e={...C(this.shape.model.rect.position,this.shape.translation)};if(tt(this.shape.translation)||(this.shape.model.rect.position=e,this.shape.connectionPoint.point=t.point,this.shape.model.points=R(this.shape.model.rect),this.shape.points=R(this.shape.model.rect)),!tt(this.shape.connectionPointTranslation)){const s=W(C(this.shape.model.rect.position,this.shape.connectionPointTranslation),this.shape.model.rect.position,N(this.shape.model.rect));let o=this.shape.connectionPoint.angle;if(s){const a=E(O(E(w(s.segment[1],s.segment[0])),90,!1,!0));o=K({x:1,y:0},a,!0),t={point:s.point,angle:o},t.point.x=Math.round(t.point.x),t.point.y=Math.round(t.point.y),this.shape.connectionPoint=t}}this.shape.translation=A(),this.shape.connectionPointTranslation=A()}}}class $t extends pt{bgColor="#000";translation=A();draw(t){const{x:e,y:s}=T(C(this.points[0],this.translation));t.beginPath(),t.moveTo(e,s);for(let o=1;o<this.points.length;o++){const{x:a,y:i}=T(C(this.points[o],this.translation));t.lineTo(a,i)}t.fillStyle=this.bgColor,t.fill()}}class b extends $t{borderColor="#000";connectionPointColor="#3ef";connectionPoint;model;connectionPointTranslation=A();constructor(t,e,s,o,a){super(t.points),this.borderColor=o,this.bgColor=s,this.connectionPointColor=a,this.connectionPoint=e,this.model=t}draw(t){const e={width:this.model.rect.size.width+it,height:this.model.rect.size.height+it},s=T(C(this.model.rect.position,this.translation));t.fillStyle=this.borderColor,t.fillRect(s.x-e.width/2,s.y-e.height/2,e.width,e.height),super.draw(t);const o=T(C(this.connectionPoint.point,this.translation));t.fillStyle=this.connectionPointColor,t.fillRect(o.x-z/2,o.y-z/2,z,z)}}class yt extends Wt{color;constructor(t,e){super(t),this.color=e}draw(t){const{x:e,y:s}=T(this.points[0]);t.beginPath(),t.moveTo(e,s);for(let o=1;o<this.points.length;o++){const{x:a,y:i}=T(this.points[o]);t.lineTo(a,i)}t.lineWidth=Dt,t.strokeStyle=this.color,t.stroke()}}class Lt{mouseDownCallbacks=[];mouseUpCallbacks=[];mouseMoveCallbacks=[];constructor(){}initialize(){}addMouseDownCallback(t){this.mouseDownCallbacks.push(t),document.addEventListener("mousedown",t)}addMouseMoveCallback(t){this.mouseDownCallbacks.push(t),document.addEventListener("mousemove",t)}addMouseUpCallback(t){this.mouseDownCallbacks.push(t),document.addEventListener("mouseup",t)}clearCallbacks(){for(const t of this.mouseDownCallbacks)document.removeEventListener("mousedown",t);for(const t of this.mouseUpCallbacks)document.removeEventListener("mouseup",t);for(const t of this.mouseMoveCallbacks)document.removeEventListener("mousemove",t)}}class kt{canvas;areaNodes=[];selectedNode=null;selectedConnectionPointNode=null;inputService;mouseDownCoordinates=null;rafID=-1;constructor(){this.inputService=new Lt}init(){if(document.querySelector("#canvas"))this.canvas=document.querySelector("#canvas"),this.canvas.width=document.documentElement.offsetWidth,this.canvas.height=document.documentElement.offsetHeight;else throw new Error("Canvas элемент не инициализирован");const e=new b(new ft({position:{x:1050,y:650},size:{width:50,height:50}}),{point:{x:1075,y:650},angle:0},"#afa","#33f","#000"),s=new b(new ft({position:{x:1e3,y:400},size:{width:50,height:50}}),{point:{x:1e3,y:375},angle:270},"#afa","#33f","#000"),o=new xt(s,null,null),a=new xt(e,o,null);o.adjacentNode=a,a.initializePathToAdjecentNode(),this.areaNodes.push(a,o),this.inputService.addMouseDownCallback(this.onMouseDownAreaNodeSelect.bind(this)),this.inputService.addMouseMoveCallback(this.onMouseMoveSelectedAreaNode.bind(this)),this.inputService.addMouseUpCallback(this.onMouseUpAreaNodeSelect.bind(this))}start(){this.rafID=requestAnimationFrame(this.render.bind(this))}render(){if(typeof this.canvas<"u"){const t=this.canvas.getContext("2d");if(this.canvas&&typeof t<"u"&&t!==null){t.clearRect(0,0,document.documentElement.offsetWidth,document.documentElement.offsetHeight);for(const e of this.areaNodes)e.adjacentNode&&e.pathToAdjacentNode&&e.pathToAdjacentNode.draw(t);for(const e of this.areaNodes)e.shape.draw(t)}}}onMouseDownAreaNodeSelect(t){const e=T({x:t.clientX,y:t.clientY});for(const s of this.areaNodes)if(s.shape instanceof b){const o={position:s.shape.connectionPoint.point,size:{width:z,height:z}};if(G(o,e)){this.selectedConnectionPointNode=s,this.mouseDownCoordinates=e;return}G(s.shape.model.rect,e)&&(this.selectedNode=s,this.mouseDownCoordinates=e)}}onMouseMoveSelectedAreaNode(t){if(this.mouseDownCoordinates){if(this.selectedNode){const e=T({x:t.clientX,y:t.clientY}),s=w(e,this.mouseDownCoordinates);this.selectedNode.assignTranslation(s,A()),this.selectedNode.createAdjacentNodePathWithTranslations(),this.render()}if(this.selectedConnectionPointNode&&this.selectedConnectionPointNode.shape instanceof b){const e=T({x:t.clientX,y:t.clientY}),s=w(e,this.mouseDownCoordinates);this.selectedConnectionPointNode.assignTranslation(A(),s),this.selectedConnectionPointNode.createAdjacentNodePathWithTranslations(),this.render()}}}onMouseUpAreaNodeSelect(){this.selectedNode&&this.selectedNode.commitTranslation(),this.selectedConnectionPointNode&&this.selectedConnectionPointNode.commitTranslation(),this.selectedNode=null,this.selectedConnectionPointNode=null,this.mouseDownCoordinates=null}}document.addEventListener("DOMContentLoaded",()=>{const n=new kt;n.init(),n.start()});
